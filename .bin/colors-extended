# Extending the built-in zsh `colors` function to have all color codes available


#export LS_COLORS="di=31;41:ln=31;41:so=31;41:pi=31;41:ex=31;41:bd=31;41:cd=31;41:su=31;41:sg=31;41:tw=31;41:ow=31;41:"

# I don't think any of this works
#/usr/bin/tic -x -o ~/.terminfo ~/.config/truecolor/xterm-24bit.terminfo
#export TERM=xterm-24bit
#set -g default-terminal "xterm-24bit"
#set -g terminal-overrides ',xterm-24bit:Tc'
# export TERM=truecolor
# export GREP_OPTIONS='--color=auto' GREP_COLOR='1;32'



# http://rtfm.etla.org/xterm/ctlseq.html
# Set cursor to be v bright
echo -ne "\033]012;rgb:6f/ff/6f\007"

# Set background to be purple
# echo -ne "\033]11;rgb:53/50/6f\007" 
# Set background back to black
# echo -ne "\033]011;rgb:00/00/00\007"
# Get the current value with ?
# printf '\033]11;?\007'



# further reading on ansi escape codes and escape codes, and tput
# https://stackoverflow.com/questions/25879183/can-terminal-app-be-made-to-respect-ansi-escape-codes
# -> learn how to use tput save/return carr: 
# echo -e "$(tput sc)Hello world$(tput rc)G'day"
# instead of 
# esc=$'\033'
# echo "${esc}7Hello world${esc}8G'day"








# (Which are ESC [ 	0x9B 	CSI 	Control Sequence Introducer 
# But if you want to read about ESC ] 	0x9D 	OSC 	Operating System Command 	, 
# look up stuff like: https://thiagowfx.github.io/2021/12/xterm-enable-ansi-osc-52/

# `ESC [`  is written by:   `\e[`    or     `\033[`
# https://xtermjs.org/docs/api/vtfeatures/

# OSCs:
# ESC ] 1 1 Pt -  	Change colors starting with text background to Pt
# Following will set term background to Pt
# echo -ne "\033]012;rgb:53/19/6f\007"

# ESC ] 1 2 Pt - Change colors starting with text cursor to Pt
# FOllowing will set term cursor to purple:
# echo -ne "\033]012;rgb:53/19/6f\007"

# so now back to CSRS:
#  Pm	A multiple numeric parameter composed of any number of single numeric parameters, separated by ; character(s). Individual values for the parameters are listed with Ps .
#  Pt 	A text parameter composed of printable characters. 

# ... so OSC use Pt, CSI uses Pm, and Pm can contain Ps
# Ps 	A single (usually optional) numeric parameter, composed of one of more digits. 

# So the reason \033]11;rgb:53/19/6f\007 can set the background purple is cause it's taking a Pt, a printable text paramtere
# We need \033[38;5;<<SOMETHING>>m to utilize the xterm 24-bit (or does it allow 32-bit?)


# https://misc.flogisoft.com/bash/tip_colors_and_formatting
# 
# for fg_bg in 38 48 ; do # Foreground / Background
#     for color in {0..255} ; do # Colors
#         # Display the color
#         printf "\e[${fg_bg};5;%sm  %3s  \e[0m" $color $color
#         #
#         # Display 6 colors per lines
#         if [ $((($color + 1) % 6)) == 4 ] ; then
#             echo # New line
#         fi
#     done
#     echo # New line
# done
#  



# Below is the rest of the `colors` zsh function

# Put standard ANSI color codes in shell parameters for easy use.
# Note that some terminals do not support all combinations.

emulate -L zsh
typeset -Ag color

# Codes listed in this array are from ECMA-48, Section 8.3.117, p. 61.
# Those that are commented out are not widely supported or aren't closely
# enough related to color manipulation, but are included for completeness.
color=(
# Attribute codes:
  00 none                 # 20 gothic
  01 bold                 # 21 double-underline
  02 faint                  22 normal
  03 italic                 23 no-italic         # no-gothic
  04 underline              24 no-underline
  05 blink                  25 no-blink
# 06 fast-blink           # 26 proportional
  07 reverse                27 no-reverse
# 07 standout               27 no-standout
  08 conceal                28 no-conceal
# 09 strikethrough        # 29 no-strikethrough

# Font selection:
  10 font-default
  11 font-first
  12 font-second
  13 font-third
  14 font-fourth
  15 font-fifth
  16 font-sixth
  17 font-seventh
  18 font-eighth
  19 font-ninth
  
# Text color codes:
  30 black                  40 bg-black
  31 red                    41 bg-red
  32 green                  42 bg-green
  33 yellow                 43 bg-yellow
  34 blue                   44 bg-blue
  35 magenta                45 bg-magenta
  36 cyan                   46 bg-cyan
  37 white                  47 bg-white
# 38 iso-8613-6           # 48 bg-iso-8613-6
  39 default                49 bg-default

# Other codes:
  50 no-proportional
  51 border-rectangle
  52 border-circle
  53 overline
  54 no-border
  55 no-overline
  56 through 59 reserved

# Ideogram markings:
  60 underline-or-right
  61 double-underline-or-right
  62 overline-or-left
  63 double-overline-or-left
  64 stress
  65 no-ideogram-marking

# Bright color codes (xterm extension)
  90 bright-gray            100 bg-bright-gray
  91 bright-red             101 bg-bright-red
  92 bright-green           102 bg-bright-green
  93 bright-yellow          103 bg-bright-yellow
  94 bright-blue            104 bg-bright-blue
  95 bright-magenta         105 bg-bright-magenta
  96 bright-cyan            106 bg-bright-cyan
  97 bright-white           107 bg-bright-white
)

# A word about black and white:  The "normal" shade of white is really a
# very pale grey on many terminals; to get truly white text, you have to
# use bold white, and to get a truly white background you have to use
# bold reverse white bg-xxx where xxx is your desired foreground color
# (and which means the foreground is also bold).

# Map in both directions; could do this with e.g. ${(k)colors[(i)normal]},
# but it's clearer to include them all both ways.
local k
for k in ${(k)color}; do
    echo $k
    color[${color[$k]}]=$k;
done

# Add "fg-" keys for all the text colors, for clarity.
for k in ${color[(I)[39]?]}; do
    color[fg-${color[$k]}]=$k;
done

# This is inaccurate, but the prompt theme system needs it.
for k in grey gray; do
    color[$k]=${color[black]}
    color[fg-$k]=${color[$k]}
    color[bg-$k]=${color[bg-black]}
done

# Assistance for the colo(u)r-blind.

for k in '' fg- bg-; do
    color[${k}bright-grey]=${color[${k}bright-gray]}
done

colour=(${(kv)color})	# A case where ksh namerefs would be useful ...

# The following are terminal escape sequences used by colored prompt themes.
local lc=$'\e['
local rc=m	\
# (Standard ANSI terminal escape values, that space is the esc char)

typeset -Hg reset_color bold_color

reset_color="$lc${color[none]}$rc"
bold_color="$lc${color[bold]}$rc"

# Foreground
typeset -AHg fg fg_bold fg_no_bold
for k in ${(k)color[(I)fg-*]}; do
    fg[${k#fg-}]="$lc${color[$k]}$rc"
    fg_bold[${k#fg-}]="$lc${color[bold]};${color[$k]}$rc"
    fg_no_bold[${k#fg-}]="$lc${color[normal]};${color[$k]}$rc"
done

# Background
typeset -AHg bg bg_bold bg_no_bold
for k in ${(k)color[(I)bg-*]}; do
    bg[${k#bg-}]="$lc${color[$k]}$rc"
    bg_bold[${k#bg-}]="$lc${color[bold]};${color[$k]}$rc"
    bg_no_bold[${k#bg-}]="$lc${color[normal]};${color[$k]}$rc"
done